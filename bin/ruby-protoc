#!/usr/bin/env ruby

$LOAD_PATH.unshift("#{File.dirname(__FILE__)}/../lib")

begin
  require 'rubygems'
rescue LoadError
end

require 'optparse'
require 'tempfile'

ruby_out = nil
d_out = nil
include_dirs = []

opts = OptionParser.new
opts.banner = <<BANNER
Usage: #{opts.program_name} [OPTION] PROTO_FILES
Parse PROTO_FILES and generate output based on the options given:
BANNER

opts.on("-o", "--ruby_out", "=OUT_DIR",
        "generates ruby code in OUT_DIR", "[defaults to pwd]",
        String) { |val| ruby_out = val }
opts.on("--d_out", "=OUT_DIR",
        "generates D code in OUT_DIR", "[not generated by default]",
        String) { |val| d_out = val }
opts.on("-I", "--proto_path", "=PATH",
        "Specify a directory to search for includes/imports.") { |val| include_dirs << val }
opts.on_tail("-h", "--help") { puts opts; exit }

rest = opts.parse(ARGV)
filenames = rest

(puts "Missing input file.\n\n"; puts opts; exit) if filenames.empty?

# hack to output ruby by default if none specified
if !ruby_out && !d_out
  ruby_out = "."
end

require 'protobuf/compiler/descriptor.pb'

protocfile = Tempfile.new("ruby-protoc")
other_opts = ""
include_dirs.each { |d| other_opts += " -I#{d}" }
`protoc #{other_opts} -o#{protocfile.path} #{filenames.join(" ")}`
descriptor_set = FileDescriptorSet.parse(protocfile)
protocfile.close(true)

if ruby_out
  require 'protobuf/compiler/file_descriptor_to_ruby'
end
if d_out
  require 'protobuf/compiler/file_descriptor_to_d'
end

descriptor_set.file.each do |file_descriptor|

  if ruby_out
    path = File.join(ruby_out,
                     File.basename(file_descriptor.name, ".proto") + ".pb.rb")
    File.open(path, "wb") do |file|
      dumper = FileDescriptorToRuby.new(file_descriptor)
      dumper.write(file)
    end
  end

  if d_out
    path = File.join(d_out,
                     File.basename(file_descriptor.name, ".proto") + "_pb.d")
    File.open(path, "wb") do |file|
      dumper = FileDescriptorToD.new(file_descriptor)
      dumper.write(file)
    end
  end

end
